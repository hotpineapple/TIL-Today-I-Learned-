# Chapter 1. Basics - nit 4. Managing connection - section 3 ~ 7

## 3. HTTP 커넥션 관리 개요

### 3.2 순차적인 트랜잭션 처리에 의한 지연

- 각 트랜잭션이 새로운 커넥션을 필요로 한다면 사용자 경험에 좋지 않은 영향
- HTTP 성능 최적화를 위한 최신 기술
    - 병렬 커넥션 : 여러개의 TCP 커넥션을 통한 동시 HTTP 요청
    - 지속 커넥션 : 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용
    - 파이프라인 커넥션 : 공유 TCP 커넥션을 통한 병렬 HTTP 요청
    - 다중 커넥션 : 요청과 응답들에 대한 중재(실험적임)

## 4. 병렬 커넥션

- 병렬 커넥션은 페이지를 더 빠르게 내려받는다
- 병렬 커넥션이 항상 더 빠르지는 않다 + 서버 성능문제 야기
    - 네트워크 대역폭이 좁은 경우
    - 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있음
- 병렬 커넥션은 더 빠르게 느껴질 수 있다
    - 화면 전체에서 여러 작업이 일어나는 것을 눈으로 확인할 수 있기 때문

## 5. 지속 커넥션

- 사이트 지역성(locality) : 서버에 HTTP 요청한 애플리케이션은 그 서버에 또 요청하게 될 것임
    - 웹 페이지에 첨부된 이미지들 대부분은 같은 웹 사이트에 있음
    - 상당수의 하이퍼링크도 같은 사이트(호스트명)를 가리킴
- HTTP/1.1 을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다
- 커넥션을 맺기 위한 준비작업에 따르는 시간 절약, 느린시작으로 인한 지연 피함

### 5.1 병렬 커넥션과 지속 커넥션

- 병렬커넥션과 비교한 장점
    - 커넥션 맺기위한 사전작업 X
    - 느린 시작 지연 X, 튜닝된 커넥션 유지
    - 커넥션의 수 적다
- 단점
    - 잘못 관리할 경우 계속 커넥션이 쌓여 로컬 리소스와 원격 클라이언트와 서버 리소스에 불필요한 소모
- 결론 : 오늘날 많은 웹 애플리케이션은 적은 수의 병렬 커넥션을 맺고 그것을 유지한다
- 지속 커넥션 타입
    - HTTP/1.0+ : Keep-Alive 커넥션
    - HTTP/1.1 : 지속 커넥션
    
### 5.2 HTTP/1.0+ : Keep-Alive 커넥션

- 동작
    - 클라이언트는 요청에 Connection: Keep-Alive 헤더를 포함
    - 서버는 이 다음 요청도 이 커넥션을 통해 받고자 한다면 응답에 같은 헤더를 포함
    - 응답에 해당 헤더가 없다면 클라이언트는 응답이 전송된 후 서버가 커넥션을 끊을 것이라고 추정함
- 옵션
    - timeout : 커넥션이 얼마나 유지될 것인지
    - max : 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지
    - 그 외 디버깅 목적 속성
- 제한과 규칙
    - HTTP/1.0 에서 기본값은 사용되지 않는 것이다
    - 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다
    - 프락시와 게이트웨이는 메시지를 전달하거나 캐시에 넣기 전에 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야 한다
- Dumb 프락시
    - Connection 헤더를 인식하지 못하는 프락시 서버
    - Connection 헤더를 제거하지 않고 그대로 다음 프락시에 전달

### 5.3 HTTP/1.1 : 지속 커넥션

- 기본적으로 활성화 되어있다
- 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection:close 헤더를 명시해야 한다
- 제한과 규칙
    - 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때에만 커넥션을 지속시킬 수 있다
    - 클라이언트는 전체 응답을 받기 전에 커넥션이 끊어지면 요청을 다시 보낼 준비가 되어있어야 한다
    - 서버의 과부하를 방지하기 위해 하나의 클라이언트는 최대 두개의 지속 커넥션만을 유지해야 한다 

## 6. 파이프라인 커넥션

- HTTP/1.1 은 지속 커넥션을 통해서 요청을 파이프라이닝 할 수 있다
- 이는 Keep-Alive 커넥션의 성능을 더 높여준다
- 파이프라이닝을 통해 네트워크 왕복으로 인한 시간을 줄일 수 있다
- 제약 사항
    - 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안된다
    - 응답은 요청 순서와 같게 와야 한다
    - 클라이언트는 커넥션이 끊어지더라도 요청이 파이프라인에 있으면 언제든 다시 보낼 준비가 되어있어야 한다
    - POST 와 같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해서 보내면 안된다 

## 7. 커넥션 끊기

- 어떤 HTTP 클라이언트, 서버 혹은 프락시는 언제든지 TCP 전송 커넥션을 끊을 수 있다
- HTTP 응답은 정확한 크기값을 가지는 Content-Length 헤더를 가지고 있어야 한다
- 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등(idempotent) 하다고 한다.
    - 요청 데이터가 전송되었지만 응답이 오기 전에 커넥션이 끊기면 클라이언트는 실제로 서버에서 얼마만큼 요청이 처리되었는지 알 수 없다
    - GET, HEAD, PUT, DELETE, TRACE 는 멱등하다
    - POST 와 같이 멱등하지 않은 요청은 파이프라인을 통해 요청하면 안된다
        - 그렇지 않으면, 전송 커넥션이 예상치 못하게 끊어져 버렸을 때 알 수 없는 결과를 초래할 수 있다
- 우아하게 커넥션 끊기
    - 전체끊기와 절반끊기
        - 전체끊기 : 입력, 출력 채널 모두 끊음, close()
        - 절반끊기 : 입력, 출력 중 하나를 개별적으로 끊음, shutdown()
    - 애플리케이션이 각기 다른 HTTP 클라이언트, 서버, 프락시와 통신하며 그들과 파이프라인 지속 커넥션을 사용할 경우, 예상치 못한 에러를 예방하기 위해 절반 끊기를 사용해야 한다
        - 보통 출력 채널을 끊는 것이 안전하다
