
## depends-on
- 일반적으로 하나의 Bean이 다른 Bean의 종속성이라는 것은 그 **빈의 속성**으로 설정됨을 의미함
- 일반적으로 XML 기반 <ref/> 요소 를 사용함. 
- 그러나 때로는 빈 간의 종속성이 덜 직접적인 경우가 있음
  - 클래스의 static 이니셜라이저를 트리거해야 하는 경우 
    - 예) 데이터베이스 드라이버 등록 
  - depends-on 속성 사용
    -빈이 초기화되기 전에 하나 이상의 빈이 초기화되도록 명시적으로 강제함

## lazy-initialized 빈
- ApplicationContext의 default 구현
  - 초기화 프로세스의 일부로 모든 싱글톤 빈 eagerly create and confifure 
- 일반적으로 이러한 사전 인스턴스화는 바람직합니다.
  - configuration 또는 주변 환경의 오류가 즉시 발견되기 때문에  
- 그러나 이 동작이 바람직하지 않은 경우에는 
  - 빈 정의를 `lazy-initialized`로 표시하여 싱글톤 빈의 사전 인스턴스화를 방지할 수도 있음 
  - 지연 초기화 빈은 IoC 컨테이너가 처음 시작할 때가 아니라 요청될 때 빈 인스턴스가 생성되도록 함
  - lazy-init속성 이용(xml)

- 지연 초기화 Bean이 지연 초기화되지 않은 싱글톤 Bean의 종속성인 경우 
  - ApplicationContext해당 싱글톤의 종속성을 충족해야 하므로 시작 시 지연 초기화 Bean을 생성하고
  - 지연 초기화되지 않은 다른 곳의 싱글톤 빈에 주입됩니다.

- component의 default-lazy-init속성을 사용하여 컨테이너 수준에서 초기화 지연을 제어할 수도 있음

## autowiring collaborators
- 장점
  - 속성이나 생성자 인수를 지정할 필요성을 줄일 수 있습니다. (빈 템플릿과 같은 다른 메커니즘 도 이와 관련)
  - 객체를 개발하면서 configuration을 업데이트할 수 있습니다. 
    - 예를 들어 클래스에 종속성을 추가해야 하는 경우 
    - configuration을 수정할 필요 없이 해당 종속성이 자동으로 충족될 수 있습니다. 
    - 코드 기반이 더 안정될 때 명시적 연결로 전환하는 옵션
- 모드
  - 없음(기본값)
  - byName
  - byType
  - 생성자
- 단점
  - property및 constructor-arg의  명시적 종속성은 항상 자동 연결을 재정의합니다. 
    - Strings, 프리미티브, Classes(및 이러한 단순 속성의 배열)과 같은 단순 속성은 자동 연결될 수 없습니다 . 
    - 이 제한은 의도적으로 설계된 것입니다.
  - 자동 배선은 명시적 배선보다 덜 정확합니다. 
    - 앞의 표에서 언급했듯이 Spring은 예기치 않은 결과를 초래할 수 있는 모호한 경우 추측을 피하기 위해 주의합니다. 
    - Spring 관리 객체 간의 관계는 더 이상 명시적으로 문서화되지 않습니다.
  - Spring 컨테이너에서 문서를 생성할 수 있는 도구에서 배선 정보를 사용하지 못할 수 있습니다.
  - 컨테이너 내의 여러 빈 정의는 자동 연결될 setter 메서드 또는 생성자 인수에 의해 지정된 유형과 일치할 수 있습니다. 배열, 컬렉션 또는 Map인스턴스의 경우 이것이 반드시 문제가 되는 것은 아닙니다. 
    - 그러나 단일 값을 기대하는 종속성의 경우 이 모호성이 임의로 해결되지 않습니다. 
    - 사용 가능한 고유한 빈 정의가 없으면 예외가 발생합니다. 
- 단점 해결
  - autowire-candidate
  - <bean> 의 primary 속성으로 기본후보 지정
  - 어노테이션을 이용하여 세분화된 제어를 구현하기
  
## 메서드 injection
- 빈 수명 주기가 다를 때 문제가 발생합니다. 
  - 싱글톤 빈 A가 싱글톤이 아닌(프로토타입) 빈 B를 사용할 필요가 있다고 가정합니다. 
  - 아마도 A에 대한 각 메서드 호출에 대해 컨테이너가 싱글톤 빈 A를 한 번만 생성하므로 속성을 설정할 기회는 한 번뿐일 것입니다. 
  - 컨테이너는 필요할 때마다 빈 B의 새 인스턴스를 빈 A에 제공할 수 없습니다.
- 해결
   - 제어의 역전을 하지 않기
    - ApplicationContextAware 인터페이스를 직접 구현
      - A가 B 를 필요로 할 때마다 컨테이너에 getBean("B")를 호출하여 B 를 요청
      - 즉 빈 A가 컨테이너를 인식하도록 
    - 비즈니스 코드가 Spring Framework를 인식하고 연결하기 때문에 바람직하지 않음
   - **메서드 주입**
   - ObjectFactory/ Provider injection point
  
- 메서드 주입 종류
  - lookup 메서드 주입
  - arbitrary 메서드 주입(설명생략)

- lookup 메서드 주입
  - 컨테이너 관리하는 Bean의 메소드를 재정의하고 
  - 컨테이너의 또 다른 명명된 Bean에 대한 lookup 결과를 리턴
  - 하는 컨테이너의 기능
  - 사용
    - `<lookup-method>`
    - `@Lookup("myCommand")`
  - 제한 사항
    - Spring Bean 컨테이너가 서브클래스인 될 수 없는 클래스와 재정의할 메소드는 final 선언할 수 없음
      - (동적 서브클래싱하기 위해)
    - 클래스를 직접 서브클래싱하고 abstract메서드의 스텁 구현을 제공해야 합니다.
      - 테스트하기 위해 
    - concrete method 이 필요
      - component 스캔(정확한 클래스를 골라야 함)하기 위해
    - lookup method가 팩토리 메서드와 동작하지 않음
      - 특히 @Bean 메서드
      - 따라서 런타임에 즉석에서 서브클래스를 생성할 수 없음
