# Dependencies
- 일반적인 엔터프라이즈 애플리케이션은 단일 객체(또는 Spring 용어로 빈)로 구성되지 않습니다.
- 완전히 실현된 애플리케이션에는 함께 작동하는 몇 가지 객체가 있습니다
- 객체가 협력하는 방법에 대한 섹션
## Dependency Injection
- 개체가 종속성을 정의하는 프로세스
- 종속성 정의 방법
  - 생성자의 인수
  - 팩토리 메서드의 인수
  - 생성된 후 개체 인스턴스에 설정된 속성을 통해서만
- 이 프로세스 이후 컨테이너는 빈을 생성할 때 이러한 종속성을 주입함
- 이는 근본적으로 빈이 자체적으로 종속성의 인스턴스화 또는 위치를 제어하는 것의 역전입니다
  - 클래스 직접 구성 또는 Service Locator 패턴을 사용
- DI 원칙을 사용하면 코드가 더 깔끔해지고 개체에 종속성이 제공될 때 분리가 더 효과적입니다.
  - 개체는 종속성을 조회하지 않으며 종속성의 위치나 클래스를 알지 못합니다.
  - 결과적으로, 특히 종속성이 인터페이스 또는 추상 기본 클래스에 있는 경우 클래스를 테스트하기가 더 쉬워짐
- DI 방법
  - 생성자 주입
  - 세터 주입

### Constructor-based Dependency Injection
- 컨테이너가 각각 종속성을 나타내는 여러 인수로 생성자를 호출
- 빈을 구성하기 위해 특정 인수를 사용하여 static 팩토리 메소드를 호출하는 것과 유사
- 생성자 인수 resolution
  - 인수 type을 이용하여 유추 가능
  - 생성자 인수가 빈 정의에서 정의되는 순서는 빈이 인스턴스화될 때 해당 인수가 적절한 생성자에 제공되는 순서
  - 생성자 인수의 유형을 명시적으로 지정 가능
  - 생성자 인수의 인덱스를 명시적으로 지정
  - 생성자 매개변수 이름을 사용할 수도 있음
    - `@ConstructorProperties` 어노테이션 사용하거나 디버그 플래그를 활성화해야함   
  
### Setter-based Dependency Injection
- 컨테이너가 인수가 없는 생성자 또는 인수가 없는 팩토리 메서드를 호출한 후 **빈에서 setter 메서드를 호출**

### 변환
- ApplicationContext 는 빈에 대해 생성자 기반 및 설정자 기반 DI를 지원
- 생성자 접근 방식을 통해 일부 종속성이 이미 주입된 후 setter 기반 DI도 가능
- PropertyEditor 로 한 형식에서 다른 형식으로 변환가능
- 하지만 대부분의 Spring 사용자는 이러한 클래스를 직접(즉, 프로그래밍 방식으로) 사용하지 않음
- 실제로 사용되는것
  - xml의 `<bean>...</bean>`
  - `@Controller`, `@Component`
  - `@bean`
- 이러한 소스는 내부적으로 BeanDefinition 인스턴스로 변환되고 전체 Spring IoC 컨테이너 인스턴스를 로드하는데 사용됨

### 비교
- 필수 종속성에는 생성자를 사용하고 
- 선택적 종속성에는 setter 메서드 또는 구성 메서드를 사용하는 것이 좋습니다. 
  - setter 메서드 에서 @Required 주석을 사용하여 속성을 필수 종속성으로 만들 수 있습니다. 
  - 그러나 프로그래밍 방식으로 인수 유효성을 검사하는 생성자 주입이 더 좋습니다.

- Spring 팀은 일반적으로 생성자 주입을 지지하는데, 
  - 이는 애플리케이션 component를 immutable 객체로 구현하고 
  - 필수 종속성이 null이 아님을 확인한다. 
  - 또한 생성자 주입 구성 요소는 항상 완전히 초기화된 상태로 클라이언트(호출) 코드에 반환됩니다. 
  - 한편 많은 수의 생성자 인수는 bad code smell이다
    - 클래스에 너무 많은 책임이 있을 수 있으며 적절한 문제 분리를 더 잘 처리하기 위해 리팩토링해야 함
- Setter 주입은 주로 클래스 내에서 합리적인 기본값을 할당할 수 있는 선택적 종속성에만 사용해야 합니다. 
  - 그렇지 않으면 코드에서 종속성을 사용하는 모든 곳에서 null이 아닌 검사를 수행해야 합니다. 
  - setter 주입의 한 가지 이점은 setter 메서드가 해당 클래스의 개체를 나중에 재구성하거나 다시 주입할 수 있도록 만든다는 것입니다. 
    - 따라서 JMX MBeans 를 통한 관리 는 setter 주입에 대한 매력적인 사용 사례입니다.
- 특정 클래스에 가장 적합한 DI 스타일을 사용하십시오. 
  - 때로는 소스가 없는 타사 클래스를 처리할 때 선택이 이루어집니다. 
  - 예를 들어, 타사 클래스가 setter 메서드를 노출하지 않는 경우 생성자 주입이 유일하게 사용 가능한 DI 형식일 수 있습니다.

### 종속성 resolution 전체 과정
1. 모든 빈을 설명 하는 설정 메타데이터를 이용해 ApplicationContext이 생성되고 초기화
  - 설정 메타데이터는 XML, Java 코드 또는 주석으로 지정할 수 있습니다.
2. 각 빈의 종속성은 속성, 생성자 인수 또는 static-factory 메서드에 대한 인수의 형태로 표현됨
  - 이러한 종속성은 Bean이 실제로 생성될 때 Bean에 제공됩니다.
3. 각 속성 또는 생성자 인수는 설정할 값의 실제 정의이거나 컨테이너의 다른 빈에 대한 참조입니다.
4. 각 속성 또는 생성자 인수(value)는 지정된 형식에서 해당 속성 또는 생성자 인수의 실제 type으로 변환됩니다. 
  - 기본적으로 Spring은 문자열 형식으로 제공된 값을 int, long, String, 등과 같은 모든 내장 유형으로 변환할 수 있

- Spring 컨테이너는 컨테이너가 생성될 때 각 빈의 configuration을 검증합니다. 
- 그러나 Bean 속성 자체는 Bean이 실제로 생성될 때까지 설정되지 않습니다. 
- 싱글톤 범위이고 사전 인스턴스화되도록 설정된(기본값) Bean은 컨테이너가 생성될 때 생성됩니다. 
  - 범위는 Bean 범위 에서 정의됩니다 . 
  - 그렇지 않으면(다르게 설정하면) Bean이 요청될 때만 생성됩니다. 
- 빈의 생성은 빈의 의존성과 의존성의 의존성(등)이 생성되고 할당됨에 따라 잠재적으로 빈의 그래프가 생성되도록 합니다. 
- 종속성 간의 resolution 불일치는 영향을 받는 빈을 처음 생성할 때 늦게 나타날 수 있습니다.

### 순환 dependency
- 주로 생성자 주입을 사용하는 경우 해결할 수 없는 순환 종속성 시나리오를 만들 수도 있음
  - 클래스 A와 B의 빈을 서로 주입하도록 구성하면 
  - Spring IoC 컨테이너는 런타임에 이 순환 참조를 감지하여 BeanCurrentlyInCreationException 던짐
- 솔루션
  - setter 주입 configuration으로 일부 클래스의 소스 코드를 수정하는 것

- 일반적으로 Spring이 올바른 일을 한다고 신뢰할 수 있습니다.
- 컨테이너 로드 시 존재하지 않는 빈 및 순환 종속성에 대한 참조와 같은 구성 문제를 감지합니다.
- Spring은 Bean이 실제로 생성될 때 가능한 한 늦게 속성을 설정하여 종속성을 resolution합니다. 
- 이것은 올바르게 로드된 Spring 컨테이너가 객체 또는 해당 종속성 중 하나를 생성하는 데 문제가 있는 경우 객체를 요청할 때 예외를 생성할 수 있음을 의미합니다. 
-  ApplicationContext의 default 구현이 **미리 인스턴스화되는** 싱글톤 빈인 이유
  - 일부 configuration issute 가시성이 잠재적으로 지연되는 것
- ApplicationContext이 생성될 때 프로그래머는 configuration 문제를 발견하게 됩니다. 
  - 이러한 빈이 실제로 필요하기 전에 생성하기 위해 약간의 선행 시간과 메모리를 대가로
- 싱글톤 빈이 eagerly 사전 인스턴스화되지 않고 lazily 초기화되도록 이 기본 동작을 재정의할 수도 있습니다.

- 순환 종속성이 없으면 하나 이상의 협업 Bean이 종속 Bean에 주입될 때 각 협업 Bean은 종속 Bean에 주입되기 전에 완전히 구성됩니다. 
  - 즉, 빈 A가 빈 B에 대한 종속성이 있는 경우 Spring IoC 컨테이너는 빈 A에 대한 setter 메서드를 호출하기 전에 빈 B를 완전히 구성합니다. ), 
  - 종속성이 설정되고 관련 수명 주기 메서드(예: 구성된 init 메서드 또는 InitializingBean 콜백 메서드 )가 호출됩니다.
