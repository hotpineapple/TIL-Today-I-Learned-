# Javascript

- 프로토타입기반 객체지향언어로서 다양한 객체생성방법을 지원함
    - 객체리터럴
    - 함수
        - object 생성자
        - object.create
        - 생성자
        - 클래스(es6)
- 프로퍼티 동적할당, 삭제 제거 가능함
- 계산된 프로퍼티 가능(표현식을 키로 사용가능하다는 뜻)

### 원시값과 객체의 비교

- immutable vs mutable
- call by value vs call by reference
    - 엄밀히말하면 call by value 도 메모리주소를 넘겨주지만 그 주소로 값에 접근하는 것임
- 원시타입
    - 원시타입 변수에 값을 재할당하면 새로운 메모리공간을 확보하고 변수가 그 공간을 가리킴
        - 재할당 불가능한 상수와는 전혀 다른개념이므로 헷갈리지말것
    - 문자열도 마찬가지임.
        - 유사배열객체로서 인덱스 접근 가능하나 읽기전용임. 이렇게는 수정 못함
        - 물론 통째로 재할당은 가능함
    - 변수에 원시값갖는 변수 할당해도 두 변수는 서로 간섭하지 않음
- 객체타입
    - 자스 객체는 리터럴 생성 및 동적 할당 가능하므로 메모리 크기를 사전에 정할 수 없음
        - 그러므로 키를 인덱스로 사용하는 해시테이블 구조 사용
        - 근데 성능이 떨어지므로 v8에서는 히든클래스 방식을 사용함
    - 객체를 할당한 변수는 객체의 주소값을 값으로 가짐(=객체를 가리킴)
        - 즉 재할당없이 객체 변경 가능
        - 객체 변경할때마다 새롭게 생성하면 신뢰성 확보되지만 성능나쁘기 때문
        - 구조적 단점: 여러 식별자가 하나의 객체를 공유가능
    - 얕은복사 vs **깊은 복사**
        - 한단계 복사 vs 중첩된 객체까지 복사
            - 한단계복사 : 참조값을 복사(=== 하면 true)
            - 중첩된 객체까지 복사 : **원시값을 복사해서** **완전히 별개의 것으로 처리됨**(=== 하면 false)

### 함수

- 스코프, 실행컨텍스트, 클로저, 생성자함수, this, 프로토타입, 모듈화 등 자스 핵심개념과 관련
- 객체타입임
    - 리터럴로 생성가능함
    - 하지만 일반 객체와 달리 호출할 수 있으며 함수만의 고유 프로퍼티를 가짐
- 함수생성방법
    - 리터럴
    - 함수 선언문
    - Function 생성자함수
    - 화살표함수(es6)
- 문맥에 따라 선언문/리터럴을 표현식으로 하기도 해석하기도 하고 표현식 아닌 문으로 해석하기도 함
- 함수선언문
    - 함수는 함수이름이 아니라 함수객체를 가지키는 식별자로 호출한다
        - 자스 엔진이 암묵적으로 함수이름과 동일한 식별자 변수만들고 걔가 함수객체 가리키도록 함
        - 만약 표현식 이용하여 다른 식별자 변수에 할당하면 그 식별자로만 호출가능함
    - 함수표현식
    - 자스의 함수는 일급객체이므로 변수에 할당가능
        - 일급객체: 변수할당, 프로퍼티값, 배열요소 가능
    - 호이스팅
        - 함수선언문으로 정의하면 선언문 이전에 호출가능
            - 함수표현식은 var 변수에 할당해도 안됨
                - 변수선언은 undefined로 초기화
                - 변수 할당은 런타임에 평가됨
        - 런타임 이전에 자스 엔진에 의해 먼저 실행되기 때문
        - **하지만 이러한 동작을 권고하지 않음. 함수표현식을 권장함**
- Function
    - 클로저를 생성하지 않음
        - 바람직하지않음
- 화살표
    - 항상 익명
    - 생성자함수로 사용불가
    - this 바인딩방식 다름
    - 프로토타입 프로퍼티 없음
    - arguments 객체 생성하지 않음
- 함수호출
    - 호출하면 매개변수는 undefined로 초기화된 뒤 인수 순서대로 값 할당됨
    - 매개변수는 함수 몸체 내부에서만 참조가능
    - 매개변수보다 인수 많으면 arguments 객체의 프로퍼티로 보관됨
        - arguments 객체는 매개변수개수를 정할 수 없을때 유용
- 인수확인
    - (typeof, arguments, 기본값 지정 등으로 유효성 확인..)
- 매개변수 개수
    - 3개 이상이면 객체 권장
- 반환문
    - 생략하면 암묵적으로 undefined반환
    - 함수몸체내부에서만 가능. 전역에서 사용하면 문법에러
- 객체를 매개변수로 할때 문제점 해결방안
    - 불변객체 생성하기
    - 옵저버패턴으로 변경시 통지하기
    - 순수함수 사용하기
- 다양한 함수
    - 즉시실행
    - 재귀
        - 내부에서는 함수이름으로 호출가능(외부에서는 식별자만 가능)
    - 콜백
        - 고차함수: 매개변수로 함수를 받거나 함수를 반환하는 함수
            - 매개변수로 전달할때 호출하면 안되고 함수자체를 전달해야함!
        - 모든 콜백함수가 고차함수에 의해 호출되는 것은 아님
            - setTimeout
        - 비동기, 배열고차함수에서 많이 사용됨
    - 중첩
        - 헬퍼함수
        - 스코프, 클로저와 연관, 거기서 다시보자

### 스코프

- 자스 엔진은 코드를 실행할 때 문맥을 고려한다
    - 코드가 어디에서 실행되며 주변에 어떤 코드가 있는지 = 렉시컬 환경
    - 스코프와 관련이 있다
- 스코프가 다르면 이름 동일 식별자 같은 값이어도 별개임
- 스코프 체인
    - 물리적으로 존재함
        - 전역 - 전역에서 선언된 함수의지역스코프 - 함수내부에서 선언된 지역스코프
    - 자스 엔진은 코드 실행 전 렉시컬 환경을 생성함
- 함수 스코프
    - 동적 스코프(호출위치에 따라 상위스코프 결정) / 렉시컬(=정적)스코프(정의위치에 따름) 중 자스는 렉시컬스코프를 따름

### 프로토타입

- 프로토타입으로 상속구현하여 중복 최소화
- 프로토타입객체는 부모 개념, 메서드 유일하게 가짐
- 생성자함수 - 프로토타입 쌍으로 존재

### this

- 함수 호출방식에 따라 this에 다른 값이 바인딩됨 → **동일한 함수도 다양한 방식으로 호출 가능!**
    - 전역, 일반함수에서 this는 window
    - 메서드: 호출한 객체(메서드를 소유한 객체-프로토타입객체-가 아님!)
    - 생성자함수: 생성될 객체
    - apply,bind,call : 첫번째로 제공된 인수로 전달된 객체
- 콜백, 중첩함수도 일반함수로 호출되면 this 에 전역객체가 바인딩됨
    - 외부함수인 메서드와 중첩/콜백함수의 this가 일치하지 않은 것은 의미가 없음
    - 외부함수의 지역변수 that에 this를 할당하거나 apply/bind/call 로 this 일치시켜주는 것이 좋음
        - apply/call : 호출
        - bind: 함수 새로 생성해서 반환, 호출은 안함

### 실행컨텍스트

- 실행컨텍스트 = 렉시컬환경 + 실행 스택

### 클로저

- https://www.youtube.com/watch?v=vKJpN5FAeF4
- https://www.youtube.com/watch?v=PVYjfrgZhtU
- 외부함수 종료되어도 내부함수에서 외부함수 지역변수 참조가능
    - 리액트 useState 훅이 클로저 활용함

```jsx
const outer = () => {
	let name = 'kim';
	const inner = () => {
		return name;
	}
  return inner;
}

const getName = outer(); // outer 종료됨
const result = getName(); // getName 함수를 통해서만 kim에 접근 가능
```

- 출처: 모던자바스크립트 딥 다이브
