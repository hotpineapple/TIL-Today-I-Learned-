# 10장 HTTP /2.0

## 배경

- HTTP/1.1의 메시지포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되어 성능이 희생됨
- HTTP의 메시지 교환 방식은 커넥션 하나를 통해 요청과 응답 각 하나만을 받으므로 회전 지연 발생
    - 이를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 근본적인 해결책이 되지는 못함
- 이러한 성능 문제를 해결하기 위한 노력들
    - WAKA 프로젝트 by HTTP/1.1 의 저자 로이 필딩
    - S+M(Speed + Mobility) 프로토콜 by Microsoft
    - 구글의 웹을 더 빠르게 하기 위한 목표의 SPDY 프로토콜
        - 기존 HTTP에 기능을 추가하여 속도 개선
        - 헤더를 압축하여 대역폭 절약
        - 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전지연을 줄임
        - 서버가 능동적으로 리소스를 푸시하는 기능
- SPDY 를 기반으로 HTTP/2.0 프로토콜을 설계
    - defalte 알고리즘을 사용하지 않게 되었다는 것 제외

## 개요

- HTTP/2.0 은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작
    - TCP 커넥션을 초기화하는 것은 클라이언트
- HTTP/2.0 의 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담김
    - 이 때 HTTP **헤더는 압축**됨
- 프레임에 담긴 요청과 응답은 **스트림**을 통해 보내짐
    - 한 개 의 스트림이 한 쌍의 요청과 응답을 처리
    - **하나의 커넥션 위에 여러 개의 스트림**이 동시에 만들어질 수 있음
    - 즉 하나의 커넥션을 통해 여러 쌍의 요청과 응답을 동시에 처리할 수 있음
    - 이 스트림들에 대한 흐름 제어와 우선순위 부여 기능이 제공됨
- 기존의 요청-응답 모델과는 다른 **서버푸시**를 도입
    - 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 요청을 명시적으로 받지 않더라도 능동적으로 보냄
- 기존 웹 애플리케이션과의 호환성을 유지하기 위해 요청과 응답 메시지의 의미는 HTTP/1.1과 같도록 유지하나 표현 문법은 변경됨
    - Content-Length(→ :content-length) : 본문의 길이
    - 404 Not Found 상태줄(→ 404값을 갖는 :status 헤더) : 리소스를 찾을 수 없음

## HTTP/1.1 과의 차이점

### 프레임

- 모든 메시지는 프레임에 담겨 전송됨(HTTP/1.1에서는 텍스트)
- 8바이트의 헤더로 시작하여 최대 16383바이트의 페이로드가 뒤이음
- 헤더의 각 필드
    - R: 예약된 비트, 0이어야 함
    - 페이로드의 길이(헤더길이는 미포함)
    - 프레임 종류
        - DATA
        - HEADERS
        - PRIORITY
        - RST_STREAM
        - SETTINGS
        - PUSH_PROMISE
        - PING
        - GOAWAY
        - WINDOW_UPDATE
        - CONTINUATION
    - 플래그
        - 프레임 종류에 따라 의미가 다름
    - 스트림 식별자
        - 0은 커넥션 전체와 연관된 프레임임을 나타냄

### 스트림과 멀티플렉싱

- 스트림 정의
    - HTTP/20 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스
- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어짐
    - 클라이언트는 새 스트림을 만들어 이를 통해 HTTP 요청을 보냄
    - 요청을 받은 서버는 그 요청과 같은 스트림으로 응답을 보냄
- HTTP/1.1
    - 하나의 TCP 커넥션을 통해 요청을 보냈을 때 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있음
    - 웹 브라우저는 회전 지연을 줄이기 위해 어러 개의  TCP 커넥션을 만들어 동시에 여러 개의 요청을 보내는 방법을 사용하지만 한계가 무한정 만들 수는 없기에 한계가 있음
    - 파이프라인 커넥션을 통해 피할 수 있으나 널리 구현되어 있지 않음
- HTTP/2.0
    - 하나의 TCP 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다
        - SETTINGS 프레임의 SETTINGS_MAX_CONCURRENT_STREAMS 값을 조정
    - 스트림의 우선순위를 정할 수 있음
        - 단 이를 따르는 것이 의무사항은 아님
    - 모든 스트림은 31비트 unsigned 정수로 이루어진 고유한 식별자를 가짐
        - 클라이언트에 의해 초기화된 경우 홀수
        - 서버에 의해 초기화된 경우 짝수
    - 식별자 값은 이전에 만들어졌거나 예약된 스트림의 식별자보다 커야함
        - 이를 어긴 경우 에러코드 PROTOCOL_ERROR인 커넥션 에러로 응답
    - 서버와 클라이언트는 상대방과의 협상 없이 일방적으로 스트림을 만듦
        - TCP 패킷을 주고받느라 시간을 낭비하지 않아도 됨
    - 스트림 흐름제어를 통해 동시에 여러 개의 스트림을 간섭없이 사용할 수 있음

### 헤더 압축

- 최근에는 웹 페이지 하나를 보기 위해 수십~수백 번의 요청을 보내기 때문에 헤더의 크기가 회전 지연과 대역폭 모두에 영향을 끼치게 됨
- 이를 개선하기 위해 HTTP/2.0 은 HPACK 명세에 정의된 방법으로 헤더를 압축하여 조각들로 나나누어 보냄

### 서버 푸시

- 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 함
- 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용함
- HTML 문서를 요청받은 경우 그 문서가 링크하고 있는 이미지, CSS 파일, 자바스크립트 파일 등의 리소스를 푸시함
    - HTML 문서를 파싱하는 트래픽과 재 요청하기까지의 회전 지연을 줄여줌
- 리소스를 푸시하려는 서버는 PUSH_PROMISE 프레임을 보내어 미리 알려주어야함
- 클라이언트에서 이를 거부하는 경우 RST_STREAM 프레임을 보내며 이 스트림은 즉각 닫힘

## 알려진 보안 이슈

- 중개자 캡슐화 공격
    - 헤더필드의 이름과 값을 바이너리 인코딩하므로 어떠한 문자열이든 사용할 수 있게 되는 문제
- 긴 커넥션 유지로 인한 개인정보 누출 우려

### HTTP/3.0

- 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 **`QUIC`**을 사용하여 통신하는 프로토콜
- 헤드오브라인 블록킹이라는 HTTP/2의 주된 문제를 해결하는 것이 목적
    - 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
- [참고]([https://velog.io/@dnr6054/HOL-Blocking](https://velog.io/@dnr6054/HOL-Blocking))
