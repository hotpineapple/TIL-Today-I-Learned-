# 운영체제 구조

## 서론

### 시스템과 운영체제

- 운영체제는 노선에 따라 구조에 큰 차이를 가짐
- 설계 전에 시스템의 목표를 정의하는 것이 중요함

### 운영체제를 바라보는 관점

- 운영체제가 제공하는 서비스
- 운영체제가 사용자와 프로그래머에게 제공하는 인터페이스
- 시스템의 구성요소와 그들의 상호 연결

### 이 장의 내용

- 운영체제의 세 가지 관점
    - 사용자, 프로그래머, 운영체제 설계자
- 운영체제가 제공하는 서비스는 무엇인지
- 이 서비스는 어떤 방식으로 제공되는지
    - 시스템 콜
- 이 서비스들은 어떻게 디버깅되는지
- 이러한 시스템을 설계하기 위해서는 어떤 방법이 사용되는지
    - 모놀리식, 계층화, 마이크로 커널, 모듈, 하이브리드 전략
- 운영체제는 어떻게 만들어지고 컴퓨터는 운영체제를 어떻게 구동시키는지
    - 운영체제 부팅 프로세스

## 운영체제가 제공하는 서비스

- 운영체제는 프로그램과 프로그램의 사용자에게 특정한 서비스를 제공함
- 이러한 서비스는 프로그래머가 프로그래밍 작업을 더 쉽게 수행할 수 있도록 함

### 많은 운영체제에서 공통적으로 제공하는 서비스들

- 사용자 인터페이스
- 프로그램 수행
- 입출력 연산
- 파일 시스템 조작
- 통신
- 오류탐지
- 자원 할당
- 기록 작성
- 보호와 보안

## 사용자와 운영체제 간 인터페이스

- 명령 인터프리터
    - 프로그래밍이 가능하므로 셸 스크립트 같은 형태가 unix, linux 시스템에서 흔하게 사용됨
- 그래픽 기반 사용자 인터페이스
- 터치스크린

## 시스템 콜

- 운영체제에 의해 사용가능하게 된 서비스에 대한 인터페이스

### 예제: 한 파일로부터 데이터를  읽어서 다른 파일로 복사하기

- 간단한 예 `cp in.txt out.txt`
- 다른 예

### api

- 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환값을 포함하여 응용프로그래머가 사용가능한 함수의 집함을 명시
- api를 구성하는 함수들이 응용 프로그래머를 대신하여 시스템콜을 호출
    - 프로그램의 호환성 측면에서 이점을 가짐
- rte(run time envioronment, 실행환경)
    - 컴파일러 또는 인터프리터를 포함
    - 특정 프로그래밍 언어로 작성된 응용프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리, 로드와 같은 다른 소프트웨어를 함께 가리킴
    - 시스템 콜에 대한 인터페이스를 제공함

### 시스템 콜의 유형

- 프로세스 제어
- 파일 조작
- 장치 조작
- 정보 유지보수
- 통신과 보호

## 시스템 서비스(시스템 유틸리티)

- 프로그램 개발과 실행을 위해 더 편리한 환경을 제공
- 일부는 단순한 시스템콜 사용자 인터페이스, 나머지는 복잡함

### 분류

- 파일 관리
- 상태 정보
- 파일 변경
- 프로그래밍 언어 지원
- 프로그램 적재와 수행
- 통신
- 백그라운드 서비스

## 링커와 로더, 재배치

- 일반적인 프로그램은 디스크에 이진실행파일로 존재함
- cpu가 이 프로그램을 실행하기 위해서 프로그램을 메모리로 가져와 프로세스 형태로 배치해야 함

### 프로그램을 cpu코어에서 실행할 수 있게 되기까지의 단계

1. 소스프로그램 main.c 
2. (컴파일러 by gcc -c main.c)
3. 재배치 가능 오브젝트 파일 main.o 
4. (링커가 다른 오브젝트 파일 또는 라이브러리와 결합* by gcc -o main main.o -lm)
5. 실행파일 main -> (로더 by ./main)
    - 5-1. 셸 : fork 시스템 콜을 사용하여 프로그램을 실행하기 위한 새 프로세스를 생성
    - 5-2. 셸: exec 에 실행파일 이름을 전달
    - 5-3. 로더: 새로 생성된 프로세스의 주소공간을 사용하여 지정된 프로그램을 메모리에 적재
6. 메모리의 프로그램
    - *동적 링크 라이브러리(dll)
    - 실제 대부분의 시스템에서는 프로그램이 메모리에 적재될 때 라이브러리를 동적으로 링크함
        - 모든 라이브러리가 실행 파일에 링크되어 메모리에 적재되지 않음
    - 여러 프로세스가 동적으로 링크된 라이브러리를 공유할 수 있어 메모리 사용이 크게 절약될 수 있음

## 운영체제의 구조

### 1. 모놀리식 구조

- 단일 주소공간의 커널에 모든 기능
- 초기 unix, linux
    - linux 는 런타임에 커널을 수정할 수 있는 모듈식 설계를 가짐
- 커널과 시스템 프로그램 두 부분으로 구성
- 구현, 확장이 어려움
- 오버헤드가 거의 없어 커널 안 통신속도가 빠름

### 2. 계층 구조

- 최하위 층(level 0)은 하드웨어, 최상위 층(level n)은 사용자 인터페이스
- 구현과 디버깅이 간단함
- 컴퓨터 네트워크 및 웹 응용 프로그램에서 성공적으로 사용됨
- 순수한 계층 접근 방식을 사용하는 운영체제는 적다
    - 각 계층의 기능을 명확히 정의해야 함
    - 사용자 프로그램이 모든 계층을 통과해야 하므로 오버헤드

### 3. 마이크로 커널

- unix가 확장함에 따라 커널 관리 힘듬
- 1980년대 mach
- 중요하지 않은 구성요소를 커널로부터 제거하고 별도의 주소공가에 사용자 수준 프로그램으로 구현
- 가중된 시스템 기능 오버헤드 때문에 성능이 나빠짐

### 4. 모듈 기법(lkm, loadable kernel modules)

- 운영체제를 설계하는 데 이용되는 최근 기술 중 최선책
- 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 또는 실행 중에 부가적인 서비스들을 모듈을 통해 링크함
- linux, mac os, solaris, windows 등의 현대 운영체제 구현의 추세
- 커널의 각 부분이 각자 정의되고 보호된 인터페이스를 가진다는 점은 계층구조와 유사하나 모듈에서 **임의의** 다른 모듈을 호출할 수 있다는 점에서 더 유연함
- 아이디어는 마이크로 커널과 유사하지만 통신을 위해 메시지 전달을 호출할 필요가 없으므로 모놀리식 시스템의 성능 이점을 유지함

## 운영체제의 부팅

1. 비휘발성 펌웨어 bios 의 부트스트랩 프로그램 또는 부트로더가 커널의 위치를 찾음
    - 많은 최신 컴퓨터 시스템이 이 과정을 uefi 로 대체함 (더 빠름)
    - grub은 linux, unix 시스템을 위한 오픈소스 부트스트랩 프로그램으로 부팅 시 커널 매개변수를 수정하거나 다른 커널을 선택할 수 있음
2. 커널이 메모링 적재되고 시작됨
3. 커널이 하드웨어를 초기화
4. 루트 파일 시스템이 마운트됨
